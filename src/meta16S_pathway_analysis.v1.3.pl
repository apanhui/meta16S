#!/usr/bin/perl
#-------------------------------------------------+
#    [APM] This script was generated by amp.pl    |
#    [APM] Created time: 2016-05-13 10:05:24      |
#-------------------------------------------------+
=pod

=head1 Name

meta16S_pathway_analysis.pl

=head1 Synopsis

perl meta16S_pathway_analysis.pl [options] <infile>

=head1 Options

 -k STR    the keyname, default [meta] 
 -o STR    the output dir, default [./]
 -s STR    the steps you want to run, default [234]
 -a STR    the align report file which created by Mothur, effective with step 1.

=head1 Feedback

 Author: Peng Ai
 Email:  aipeng0520@163.com

=head1 Version

Version history

=head2 v1.0

Date: 2016-05-13 10:05:24

=head2 v1.1 

Date: 01/19/2017 01:04:29 PM

Update: add -a option to fetch the NSTI score whlie run predict_metagenomes.py

=head2 v1.2

Date: 02/27/2017 05:32:29 PM

Update: add step 5, turn picrust result to psf format for STAMP 

=head2 v1.3 

Date: 05/26/2017 07:54:43 PM

Update: add the step1 and option -a

=cut

use strict;
use warnings;

use FindBin qw/$Bin/;
use Getopt::Std;
use Cwd 'abs_path';
use Tie::File;
use List::Util qw/sum/;

#-------------------------------------------------------------------------------
#  config the software path 
#-------------------------------------------------------------------------------
my $pick = "/Bio/User/luoyue/Lib_Jan2016/Python/bin/pick_closed_reference_otus.py";
my $normalize = "/Bio/User/luoyue/Lib_Jan2016/Python/ENV/bin/normalize_by_copy_number.py";
my $predict = "/Bio/User/luoyue/Lib_Jan2016/Python/ENV/bin/predict_metagenomes.py";
my $categorize = "/Bio/User/luoyue/Lib_Jan2016/Python/ENV/bin/categorize_by_function.py";

#-------------------------------------------------------------------------------
#  input 
#-------------------------------------------------------------------------------
my %opts = (s=>'234',o=>".",k=>"meta");
getopts('s:o:k:a:',\%opts);

die `pod2text $0` unless @ARGV == 1;

my $infile = shift @ARGV;

#-------------------------------------------------------------------------------
#  main 
#-------------------------------------------------------------------------------
$infile = abs_path($infile);
$opts{o} = abs_path($opts{o});
mkdir $opts{o} unless -d $opts{o};

my $cmd;

if ($opts{s} =~ /1/)
{
	die "you must define the greengene align file" unless ($opts{a} && -e $opts{a});
	$infile = create_infile($opts{a},$infile);
}

if ($opts{s} =~ /2/)
{
	$cmd .= "#============= Do the OTU abundance normalization =====================\n";
	$cmd .= "date +\"[%F %T] run normalization ...\" \n";
	#$cmd .= "$normalize -f -i $infile -o $opts{o}/$opts{k}.picrust.normalize.biom; \n\n";
	$cmd .= "$normalize -i $infile -o $opts{o}/$opts{k}.picrust.normalize.biom; \n\n";
	$infile = "$opts{o}/$opts{k}.picrust.normalize.biom";
}

if ($opts{s} =~ /3/)
{
	$cmd .= "#============= Do the ko function predict =====================\n";
	$cmd .= "date +\"[%F %T] run predict function ...\" \n";
	$cmd .= "$predict -i $infile --type_of_prediction ko -o $opts{o}/$opts{k}.ko.predict.biom; \n";
	$cmd .= "$predict -f -i $infile --type_of_prediction ko -o $opts{o}/$opts{k}.ko.predict.tsv -a $opts{o}/$opts{k}.ko.NSTI.tab; \n\n";
	$infile = "$opts{o}/$opts{k}.ko.predict.biom";
}

if ($opts{s} =~ /4/)
{
	$cmd .= "#============= Do categorize with the predict function of ko =====================\n";
	$cmd .= "date +\"[%F %T] run categorize of function ...\" \n";
	$cmd .= "$categorize -i $infile -c KEGG_Pathways -l 3 -o $opts{o}/$opts{k}.pathway.L3.biom; \n";
	$cmd .= "$categorize -f -i $infile -c KEGG_Pathways -l 3 -o $opts{o}/$opts{k}.pathway.L3.tsv; \n\n";
}

$cmd .= "date +\"[%F %T] finish !\"\n";

# output the cmd to shell 
open SH,">ko.annot.sh" or die $!;
print SH $cmd;
close SH;

system("sh ko.annot.sh");

if ($opts{s} =~ /3/)
{
	# replace the header of the output file, (OTU ID => KO id)
	tie my @array , 'Tie::File' , "$opts{o}/$opts{k}.ko.predict.tsv" or die $!;
	shift @array if ($array[0] =~ /^#/);
	$array[0] =~ s/#OTU ID/KO id/;
	untie @array;
	
	open my $fh  , "<" , "$opts{o}/$opts{k}.ko.predict.tsv" or die $!;
	open my $ofh , ">" , "$opts{o}/$opts{k}.ko.annot.xls" or die $!;
	my $head = <$fh>;
	print $ofh $head;
	while(<$fh>)
	{
		chomp;
		my ($id,@vals) = (split /\t/);
		pop @vals;
		next if (sum(@vals) == 0);
		print $ofh $_ , "\n";
	}
	close $fh;
	close $ofh;
}

if ($opts{s} =~ /4/)
{
	# replace the header of the output file, (OTU ID => Pathway)
	tie my @array , 'Tie::File' , "$opts{o}/$opts{k}.pathway.L3.tsv" or die $!;
	shift @array if ($array[0] =~ /^#/);
	$array[0] =~ s/#OTU ID/Pathway/;
	untie @array;
	
	open my $fh  , "<" , "$opts{o}/$opts{k}.pathway.L3.tsv" or die $!;
	open my $ofh , ">" , "$opts{o}/$opts{k}.pathway.annot.xls" or die $!;
	my $head = <$fh>;
	print $ofh $head;
	while(<$fh>)
	{
		chomp;
		my ($id,@vals) = (split /\t/);
		pop @vals;
		next if (sum(@vals) == 0);
		print $ofh $_ , "\n";
	}
	close $fh;
	close $ofh;
}

#-------------------------------------------------------------------------------
# turn the pathway annot result to psf format and fetch the group metadata file for STAMP software 
#-------------------------------------------------------------------------------
if ($opts{s} =~ /5/)
{
	open IN,"$opts{o}/$opts{k}.pathway.annot.xls" or die $!;

	my $head = <IN>;
	my ($tmp1,@samples) = split /\t/,$head;
	pop @samples;

	open OUT,">$opts{o}/$opts{k}.pathway.L3.spf" or die $!;

	my $sample_names = join "\t",@samples;
	print OUT "Level_1\tLevel_2\tLevel_3\tObservation Ids\t$sample_names\n";

	while(<IN>)
	{
		chomp;
		next if (/^#/);
		
		my ($id,@vals) = split /\t/;
		my $category = pop @vals;
		my @levels = split /;/,$category;

		next if ($levels[0] eq "Unclassified");

		my $vals = join "\t" , @vals;
		print OUT "$levels[0]\t$levels[1]\t$levels[2]\t$id\t$vals\n";
	}

	close IN;
}

sub create_infile
{
	my ($align_file,$otu_abu) = @_;
	
	my ($samples,%abundnace) = read_otu_abu($otu_abu);
	my %align = read_align($align_file);

	open my $ofh , ">" , "$opts{o}/$opts{k}.picrust.tab" or die $!;
	
	my $head = join "\t" , ("Otu_id",@$samples);
	print $ofh $head , "\n";
	foreach my $taxid (keys %align)
	{
		my @otuids = @{$align{$taxid}};
		my @tags;
		foreach my $otuid (@otuids)
		{
			map { $tags[$_] += $abundnace{$otuid}->[$_] } 0 .. $#$samples;
		}

		my @relative = map {  sprintf "%.6f" , $tags[$_]*100/$abundnace{total_tags}->[$_]  } 0 .. $#tags;
		my $line = join "\t" , ($taxid,@relative);
		print $ofh $line , "\n";
	}

	close $ofh;

	return "$opts{o}/$opts{k}.picrust.tab";
}

sub read_otu_abu
{
	my $file = shift ;
	my %abundnace;

	open my $fh , $file or die $!;
	my $head = <$fh>;
	my @samples = split /\t/,$head;
	shift @samples;
	pop @samples;
	
	my @sums;
	while(<$fh>)
	{
		my ($otuid,@vals) = split /\t/,$_;
		pop @vals;

		$abundnace{$otuid} = \@vals;
		map { $sums[$_] += $vals[$_] } 0 .. $#vals;
	}
	close $fh;
	
	$abundnace{total_tags} = \@sums;
	return (\@samples,%abundnace);
}

sub read_align
{
	my $file = shift;
	my %align;

	open my $fh,$file or die $!;
	<$fh>;
	while(<$fh>)
	{
		chomp;
		my ($otuid,$taxid) = (split /\t/)[0,2];
		push @{$align{$taxid}} , $otuid;
	}
	close $fh;

	return %align;
}
